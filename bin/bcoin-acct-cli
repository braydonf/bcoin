#!/usr/bin/env node

'use strict';

const readline = require('readline');
const assert = require('bsert');
const fs = require('bfile');
const Config = require('bcfg');
const NodeClient = require('../lib/client/node');

const ports = {
  main: 8332,
  testnet: 18332,
  regtest: 48332,
  simnet: 18556
};

class CLI {
  constructor() {
    this.config = new Config('bcoin', {
      suffix: 'network',
      fallback: 'main',
      alias: {
        'n': 'network',
        'u': 'url',
        'uri': 'url',
        'k': 'api-key',
        's': 'ssl',
        'h': 'httphost',
        'p': 'httpport'
      }
    });

    this.config.load({
      argv: true,
      env: true
    });

    this.config.open('bcoin.conf');

    this.argv = this.config.argv;
    this.network = this.config.str('network', 'main');

    this.client = new NodeClient({
      url: this.config.str('url'),
      apiKey: this.config.str('api-key'),
      ssl: this.config.bool('ssl'),
      host: this.config.str('http-host'),
      port: this.config.uint('http-port')
        || ports[this.network]
        || ports.main
    });
  }

  log(json) {
    if (typeof json === 'string')
      return console.log.apply(console, arguments);
    return console.log(JSON.stringify(json, null, 2));
  }

  async open() {
    switch (this.argv.shift()) {
      case 'txs':
        await this.getTxs();
        break;
      case 'deltas':
        await this.createDeltas();
        break;
      default:
        this.log('Unrecognized command.');
        this.log('Commands:');
        this.log('  $ txs: Get transactions from addresses.');
        this.log('  $ deltas: Get balance deltas from transactions.');
        break;
    }
  }

  async getTxs() {
    const input = this.config.str(0, '');

    if (!input)
      throw new Error('Unknown input filename.');

    const addrs = await fs.readJSON(input);

    for (let i = 0; i < addrs.length; i++) {
      const acct = addrs[i];

      for (let j = 0; j < acct.length; j++) {
        const addr = acct[j];
        let txs = await this.client.get(`/tx/address/${addr}`);

        while (txs.length > 0) {
          const hash = txs[txs.length - 1].hash;
          const next = await this.client.get(
            `/tx/address/${addr}?after=${hash}`);

          if (next.length > 0)
            txs = txs.concat(next);
          else
            break;
        }

        const str = JSON.stringify({index: i, addr: addr, txs: txs});

        process.stdout.write(str + '\n');
      }
    }
  }

  async createDeltas() {
    const addrinput = this.config.str(0, '');
    const txinput = this.config.str(1, '');

    if (!addrinput)
      throw new Error('Unknown addrinput filename.');

    if (!txinput)
      throw new Error('Unknown txinput filename.');

    const addrsData = await fs.readJSON(addrinput);
    const addrs = new Set();
    for (const acct of addrsData) {
      for (const addr of acct)
        addrs.add(addr);
    }

    class Row {
      constructor(options = {}) {
        this.hash = options.hash || null;
        this.fee = options.fee || 0;
        this.mtime = options.mtime || 0;
        this.height = options.height || 0;
        this.block = options.block || null;
        this.time = options.time || 0;
        this.delta = options.delta || 0;
        this.spending = options.spending || [];
        this.receiving = options.receiving || [];
      }

      static headers() {
        return Object.keys(new this()).join(',');
      }

      values() {
        const clone = Object.assign({}, this);
        clone.spending = this.spending.join(' ');
        clone.receiving = this.receiving.join(' ');

        return Object.values(clone).join(',');
      }
    }

    function processTx(tx) {
      let delta = 0;
      const inputInfo = [];
      const outputInfo = [];

      if (tx.inputs) {
        for (const input of tx.inputs) {
          const info = {
            addr: input.coin.address,
            value: input.coin.value,
            wallet: false
          };

          assert(Number.isInteger(info.value));

          if (addrs.has(info.addr)) {
            delta -= info.value;
            info.wallet = true;
          }

          inputInfo.push(info);
        }
      }

      for (const output of tx.outputs) {
        const info = {
          addr: output.address,
          value: output.value,
          wallet: false
        }

        assert(Number.isInteger(info.value));

        if (addrs.has(info.addr)) {
          delta += info.value;
          info.wallet = true;
        }

        outputInfo.push(info);
      }

      const row = new Row({
        hash: tx.hash,
        fee: tx.fee,
        mtime: tx.mtime,
        height: tx.height,
        block: tx.block,
        time: tx.time,
        delta: delta
      });

      if (delta > 0) {
        for (const info of inputInfo) {
          if (!info.wallet && info.value > 0)
            row.spending.push(info.addr);
        }

        for (const info of outputInfo) {
          if (info.wallet && info.value > 0)
            row.receiving.push(info.addr);
        }
      } else if (delta < 0) {
        for (const info of inputInfo) {
          if (info.wallet && info.value > 0)
            row.spending.push(info.addr);
        }

        for (const info of outputInfo) {
          if (!info.wallet && info.value > 0)
            row.receiving.push(info.addr);
        }
      }

      return row;
    }

    return new Promise((resolve, reject) => {
      const rl = readline.createInterface({
        input: fs.createReadStream(txinput)
      });

      const txsSeen = new Set();

      process.stdout.write(Row.headers() + '\n');

      rl.on('line', (line) => {
        try {
          const data = JSON.parse(line);
          const txs = data.txs;

          for (const tx of txs) {
            if (txsSeen.has(tx.hash))
              continue;

            const row = processTx(tx);

            process.stdout.write(row.values() + '\n');

            txsSeen.add(tx.hash);
          }
        } catch (err) {
          reject(err);
        }
      });

      rl.once('close', () => resolve());
    });
  }

  async destroy() {
    if (this.client && this.client.opened)
      await this.client.close();
  }
}

(async () => {
  const cli = new CLI();
  await cli.open();
  await cli.destroy();
})().catch((err) => {
  console.error(err.stack);
  process.exit(1);
});
